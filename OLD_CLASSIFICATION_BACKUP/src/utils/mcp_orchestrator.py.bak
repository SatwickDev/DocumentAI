"""
MCP Orchestrator - Manages communication between multiple MCP servers
Provides the missing contracts and inter-server communication
"""

import asyncio
import json
import loggi            # Verify process is running
            if not self.process or self.process.returncode is not None:
                raise Exception("Server process is not running")
                
            # Convert request to JSON and send
            request_json = json.dumps(request.to_json()) + "\n"
            try:
                self.process.stdin.write(request_json.encode())
                await self.process.stdin.drain()
            except (BrokenPipeError, ConnectionError) as e:
                raise Exception(f"Failed to send request: {e}")

            # Read response with timeout
            try:
                response_line = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=self.config.timeout
                )
            except asyncio.TimeoutError:
                raise Exception(f"No response received after {self.config.timeout} seconds")

            if not response_line:
                raise Exception("Empty response received")

            response_text = response_line.decode().strip()

            # Parse and validate response
            try:
                response_dict = json.loads(response_text)
                validate_mcp_response(response_dict)
                return MCPResponse.from_json(response_text)
            except json.JSONDecodeError as e:
                raise Exception(f"Invalid JSON response: {e}")
            except Exception as e:
                raise Exception(f"Invalid response format: {e}")mport uuid
import os
import sys
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from .mcp_contracts import (
    MCPRequest, MCPResponse, MCPMethods, MCPErrors,
    validate_mcp_request, validate_mcp_response,
    create_mcp_error_response, create_mcp_success_response
)

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ServerConfig:
    """Configuration for an MCP server"""
    name: str
    script_path: str
    timeout: float = 30.0
    max_retries: int = 3

class MCPClient:
    """Client for communicating with a single MCP server"""
    
    def __init__(self, server_config: ServerConfig):
        self.config = server_config
        self.process = None
        self.is_connected = False
        self.request_counter = 0
    
    async def connect(self) -> bool:
        """Connect to the MCP server"""
        try:
            logger.info(f"Connecting to MCP server: {self.config.name}")
            
            # Clean up any existing process
            if self.process:
                try:
                    self.process.terminate()
                    await self.process.wait()
                except:
                    pass
            
            # Ensure script path exists
            if not os.path.isfile(self.config.script_path):
                logger.error(f"‚ùå Script not found at {self.config.script_path}")
                return False
            
            logger.info(f"Starting script: {self.config.script_path}")
            
            # Start process with unbuffered output
            env = os.environ.copy()
            env['PYTHONUNBUFFERED'] = '1'
            
            self.process = await asyncio.create_subprocess_exec(
                sys.executable, self.config.script_path,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=os.path.dirname(self.config.script_path),
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0
            )
            
            # Give the process a chance to start
            await asyncio.sleep(0.5)
            
            # Read startup errors if any
            if self.process.stderr:
                error = await self.process.stderr.read(1024)
                if error:
                    logger.error(f"‚ùå Server startup error for {self.config.name}: {error.decode()}")
                    return False

            # Wait a bit for server initialization
            await asyncio.sleep(1)
            
            # Test connection with tools/list
            test_request = MCPRequest(
                id=0,
                method=MCPMethods.TOOLS_LIST
            )
            
            # Try multiple times with backoff
            max_attempts = 3
            for attempt in range(max_attempts):
                if attempt > 0:
                    await asyncio.sleep(attempt * 2)  # Exponential backoff
                    
                logger.info(f"Connection attempt {attempt + 1} for {self.config.name}")
                response = await self._send_request(test_request)
                
                if response and not response.error:
                    self.is_connected = True
                    logger.info(f"‚úÖ Connected to {self.config.name}")
                    return True
            else:
                logger.error(f"‚ùå Failed to connect to {self.config.name}: {response.error if response else 'No response'}")
                await self.process.wait()  # Wait for process exit
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Connection error for {self.config.name}: {e}")
            return False
    
    async def disconnect(self):
        """Disconnect from the MCP server"""
        if self.process:
            try:
                self.process.terminate()
                await self.process.wait()
                logger.info(f"Disconnected from {self.config.name}")
            except Exception as e:
                logger.error(f"Error disconnecting from {self.config.name}: {e}")
        
        self.is_connected = False
        self.process = None
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any], timeout: Optional[float] = None) -> Dict[str, Any]:
        """Call a tool on the MCP server"""
        if not self.is_connected:
            raise Exception(f"Not connected to {self.config.name}")
        
        self.request_counter += 1
        request = MCPRequest(
            id=self.request_counter,
            method=MCPMethods.TOOLS_CALL,
            params={
                "name": tool_name,
                "arguments": arguments
            }
        )
        
        timeout = timeout or self.config.timeout
        
        try:
            response = await asyncio.wait_for(
                self._send_request(request),
                timeout=timeout
            )
            
            if response.error:
                raise Exception(f"MCP tool call failed: {response.error}")
            
            return response.result
            
        except asyncio.TimeoutError:
            raise Exception(f"MCP tool call timed out after {timeout}s")
        except Exception as e:
            logger.error(f"Tool call failed for {self.config.name}.{tool_name}: {e}")
            raise
    
    async def list_tools(self) -> List[Dict[str, Any]]:
        """List available tools from the MCP server"""
        if not self.is_connected:
            raise Exception(f"Not connected to {self.config.name}")
        
        self.request_counter += 1
        request = MCPRequest(
            id=self.request_counter,
            method=MCPMethods.TOOLS_LIST
        )
        
        response = await self._send_request(request)
        
        if response.error:
            raise Exception(f"Failed to list tools: {response.error}")
        
        return response.result.get("tools", [])
    
    async def _send_request(self, request: MCPRequest) -> MCPResponse:
        """Send request to MCP server and get response"""
        if not self.process:
            raise Exception("No process available")
        
        try:
            # Validate request
            request_dict = json.loads(request.to_json())
            validate_mcp_request(request_dict)
            
            # Send request
            request_json = request.to_json() + "\n"
            self.process.stdin.write(request_json.encode())
            await self.process.stdin.drain()
            
            # Read response
            response_line = await self.process.stdout.readline()
            
            if not response_line:
                raise Exception("No response received")
            
            response_text = response_line.decode().strip()
            
            # Parse and validate response
            response_dict = json.loads(response_text)
            validate_mcp_response(response_dict)
            
            return MCPResponse.from_json(response_text)
            
        except Exception as e:
            logger.error(f"Request failed for {self.config.name}: {e}")
            return create_mcp_error_response(
                request.id,
                MCPErrors.INTERNAL_ERROR,
                str(e)
            )

class MCPOrchestrator:
    """Orchestrates communication between multiple MCP servers"""
    
    def __init__(self):
        self.servers: Dict[str, ServerConfig] = {}
        self.clients: Dict[str, MCPClient] = {}
        self.is_initialized = False
    
    def register_server(self, server_config: ServerConfig):
        """Register an MCP server"""
        self.servers[server_config.name] = server_config
        logger.info(f"Registered MCP server: {server_config.name}")
    
    async def initialize(self) -> bool:
        """Initialize all registered servers"""
        if self.is_initialized:
            return True
        
        logger.info("Initializing MCP Orchestrator...")
        success_count = 0
        retries = 3
        
        try:
            for attempt in range(retries):
                if attempt > 0:
                    logger.info(f"Retry attempt {attempt + 1}/{retries}...")
                    await asyncio.sleep(attempt * 2)  # Exponential backoff
                
                # Try to connect to all unconnected servers
                for server_name, server_config in self.servers.items():
                    if server_name in self.clients:  # Skip already connected servers
                        success_count += 1
                        continue
                        
                    try:
                        client = MCPClient(server_config)
                        connected = await client.connect()
                        
                        if connected:
                            self.clients[server_name] = client
                            success_count += 1
                    except Exception as e:
                        logger.error(f"Failed to initialize {server_name}: {e}")
                        if server_name in self.clients:
                            await self.clients[server_name].disconnect()
                            del self.clients[server_name]
                
                # Check if we have all servers connected
                if success_count == len(self.servers):
                    logger.info("‚úÖ All servers initialized successfully")
                    self.is_initialized = True
                    return True
            
            # After all retries, check if we have at least one server
            self.is_initialized = success_count > 0
            if self.is_initialized:
                logger.warning(f"Partial initialization: {success_count}/{len(self.servers)} servers connected")
                return True
            else:
                logger.error("‚ùå No servers could be initialized")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Global initialization error: {e}")
            return False
                    
                    # Log available tools
                
                # Check initialization success
                if success_count == len(self.servers):
                    logger.info("All servers initialized successfully")
                    break  # Exit retry loop if all servers connected
                
                if attempt == retries - 1:
                    logger.warning("Not all servers could be initialized after retries")
        
        self.is_initialized = success_count > 0
        logger.info(f"Initialized {success_count}/{len(self.servers)} MCP servers")
        
        return self.is_initialized
    
    async def shutdown(self):
        """Shutdown all MCP clients"""
        logger.info("Shutting down MCP Orchestrator...")
        
        for client in self.clients.values():
            await client.disconnect()
        
        self.clients.clear()
        self.is_initialized = False
    
    async def call_tool(self, server_name: str, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Call a tool on a specific server"""
        if not self.is_initialized:
            raise Exception("Orchestrator not initialized")
        
        if server_name not in self.clients:
            raise Exception(f"Server not available: {server_name}")
        
        client = self.clients[server_name]
        return await client.call_tool(tool_name, arguments)
    
    async def call_multiple_tools(self, operations: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Call multiple tools in parallel across different servers
        
        operations format:
        [
            {
                "server": "classification",
                "tool": "classify_document", 
                "arguments": {"file_path": "/path/to/doc.pdf"}
            },
            {
                "server": "quality",
                "tool": "analyze_document_quality",
                "arguments": {"file_path": "/path/to/doc.pdf"}
            }
        ]
        """
        if not self.is_initialized:
            raise Exception("Orchestrator not initialized")
        
        start_time = time.time()
        tasks = []
        task_info = []
        
        # Create tasks for parallel execution
        for operation in operations:
            server_name = operation["server"]
            tool_name = operation["tool"]
            arguments = operation["arguments"]
            
            if server_name not in self.clients:
                logger.warning(f"Server not available: {server_name}")
                continue
            
            task = asyncio.create_task(
                self.call_tool(server_name, tool_name, arguments),
                name=f"{server_name}.{tool_name}"
            )
            
            tasks.append(task)
            task_info.append({
                "server": server_name,
                "tool": tool_name,
                "arguments": arguments
            })
        
        # Execute all tasks in parallel
        results = {}
        errors = {}
        
        if tasks:
            completed_tasks = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(completed_tasks):
                info = task_info[i]
                server_name = info["server"]
                
                if isinstance(result, Exception):
                    logger.error(f"Task failed - {server_name}: {result}")
                    errors[server_name] = str(result)
                else:
                    results[server_name] = result
                    logger.info(f"Task completed - {server_name}")
        
        processing_time = time.time() - start_time
        
        return {
            "success": len(results) > 0,
            "results": results,
            "errors": errors,
            "tasks_requested": len(operations),
            "tasks_completed": len(results),
            "tasks_failed": len(errors),
            "processing_time_seconds": round(processing_time, 3),
            "timestamp": time.time()
        }
    
    async def get_server_status(self) -> Dict[str, Any]:
        """Get status of all servers"""
        status = {
            "orchestrator": {
                "initialized": self.is_initialized,
                "servers_registered": len(self.servers),
                "clients_connected": len(self.clients)
            },
            "servers": {}
        }
        
        for server_name, client in self.clients.items():
            try:
                # Test connection by listing tools
                tools = await client.list_tools()
                status["servers"][server_name] = {
                    "status": "healthy",
                    "connected": client.is_connected,
                    "tools_count": len(tools),
                    "tools": [tool.get("name") for tool in tools[:3]]  # First 3 tools
                }
            except Exception as e:
                status["servers"][server_name] = {
                    "status": "unhealthy",
                    "connected": False,
                    "error": str(e)
                }
        
        return status

# =============================================================================
# Example Usage and Testing
# =============================================================================

async def example_orchestrated_processing():
    """Example of orchestrated document processing"""
    
    # Create orchestrator
    orchestrator = MCPOrchestrator()
    
    # Register servers
    orchestrator.register_server(ServerConfig(
        name="classification",
        script_path="classification_mcp_server.py",
        timeout=30.0
    ))
    
    orchestrator.register_server(ServerConfig(
        name="quality",
        script_path="quality_mcp_server.py", 
        timeout=60.0
    ))
    
    try:
        # Initialize all servers
        initialized = await orchestrator.initialize()
        
        if not initialized:
            print("‚ùå Failed to initialize orchestrator")
            return
        
        # Get server status
        status = await orchestrator.get_server_status()
        print("üìä Server Status:")
        print(json.dumps(status, indent=2))
        
        # Process document using multiple servers
        operations = [
            {
                "server": "classification",
                "tool": "classify_document",
                "arguments": {
                    "file_path": "/path/to/document.pdf",
                    "session_id": "example_session_123"
                }
            },
            {
                "server": "quality",
                "tool": "analyze_document_quality",
                "arguments": {
                    "file_path": "/path/to/document.pdf",
                    "session_id": "example_session_123"
                }
            }
        ]
        
        print("\nüöÄ Processing document with multiple servers...")
        results = await orchestrator.call_multiple_tools(operations)
        
        print("üìã Results:")
        print(json.dumps(results, indent=2))
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        
    finally:
        # Cleanup
        await orchestrator.shutdown()

if __name__ == "__main__":
    asyncio.run(example_orchestrated_processing())
